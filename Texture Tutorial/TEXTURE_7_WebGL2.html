<html>
<head>
    <title> WebGL </title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

    <script type="text/javascript" src="gl-matrix.js"></script>
    <script id = "vertex_shader" type="x-shader/x-vertex">
        #version 300 es
        
        layout(location = 0) in vec4 aPosition;
        layout(location = 1) in vec2 aTexCoord;
        
        uniform vec2 uvOffset;
        uniform vec2 uvScale;

        out vec2 vTexCoord;
        void main(){
            vTexCoord = aTexCoord * uvScale + uvOffset;
            gl_Position = aPosition;
        }
      </script>
    <script id = "fragment_shader" type="x-shader/x-fragment">
        #version 300 es

        precision mediump float;

        in vec2 vTexCoord;
        
        uniform sampler2D uSampler;
                
        out vec4 fragColor;

        void main(){
            fragColor = texture(uSampler,vTexCoord);
        }

        </script>

    <script type="text/javascript">

        function getShader(gl, id, str){

            var shader;
            if(id == 'vs'){
                shader = gl.createShader(gl.VERTEX_SHADER);

            }else if(id=='fs'){
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            }else {
                return null;
            }
            gl.shaderSource(shader, str);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;

        }

        function getProgram(gl,vShader,fShader) {

            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram,vShader);
            gl.attachShader(shaderProgram,fShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.log(gl.getShaderInfoLog(vShader));
                console.log(gl.getShaderInfoLog(fShader));
            }
            return shaderProgram;

        }

        function createDomShaderProgram(gl, vectId,fragId) {

            var vShaderTxt = document.getElementById(vectId).text.trim();                      if(!vShaderTxt) return null;
            var fShaderTxt = document.getElementById(fragId).text.trim();                      if(!fShaderTxt) return null;
            var vShader = getShader(gl,'vs',vShaderTxt);                                if(!vShader)    return null;
            var fShader = getShader(gl,'fs',fShaderTxt);                                if(!fShader)    return null;

            if(!fShader) {gl.deleteShader(vShader);  return null;}

            var shaderProgram = getProgram(gl,vShader,fShader);

            return shaderProgram;
        }

        function initGl() {

            canvas = document.getElementById("canvasGL");
            if (!canvas){
                console.log('failed');
                return;
            }
            canvas.width  = 300;
            canvas.height = 300;

            try {

                gl = canvas.getContext("webgl", {antialias: false});

            } catch (e) {
                alert("You are not webgl compatible :(");
                return false;
            }

            return gl;
        }

        function webGLStart() {
            /** @type {HTMLCanvasElement} */
            const canvas = document.getElementById("canvasGL");
            if (!canvas){
                console.log('failed');
                return;
            }
            canvas.width  = 500;
            canvas.height = 500;

            try {
                /** @type {WebGLRenderingContext} */
                gl = canvas.getContext("webgl2", {antialias: true});

            } catch (e) {
                alert("You are not webgl compatible :(");
                return false;
            }


            let shaderProgram  = createDomShaderProgram(gl,"vertex_shader","fragment_shader");
            gl.useProgram(shaderProgram);
            let u_sampler   = gl.getUniformLocation(shaderProgram,'uSampler');
            gl.uniform1i(u_sampler, 0);

            const u_uvOffset = gl.getUniformLocation(shaderProgram, "uvOffset");
            const uvScale = gl.getUniformLocation(shaderProgram, "uvScale");

            ///** BufferData --------------------------------------------------------------
            const vertexBufferData = new Float32Array([
                -1.0, 1.0,
                -1.0, -1.0,
                1.0,  1.0,
                1.0, -1.0,
            ]);

            const frame = 1;
            const pading =  0.3287671232876712;
            const texCoordBufferData = new Float32Array([
                0 , 1,
                0 , 0,
                1 , 1,
                1 , 0,
            ]);

            const frameUV = [
                [0.0,0.6666],
                [0.3333,0.6666],
                [0.6666, 0.6666],
                [0.0, 0.3333],
                [0.3333, 0.3333],
                [0.0, 0.0],
                [0.3333, 0.0]
            ];

            // const pixels = new Uint8Array([
            //     255, 255, 255, 230, 25, 75, 60, 180, 75, 255, 225, 25,
            //     67, 99, 216, 245, 130, 49, 145, 30, 180, 70, 240, 240,
            //     240, 50, 230, 188, 246, 12, 250, 190, 190, 0, 128, 128,
            //     230, 190, 255, 154, 99, 36, 255, 250, 200, 0, 0, 0,
            // ]);

            // const pixelBuffer = gl.createBuffer();
            // gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, pixelBuffer);
            // gl.bufferData(gl.PIXEL_UNPACK_BUFFER, pixels, gl.STATIC_DRAW);

            const vertexBuffer  = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexBufferData, gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0,0,);
            gl.enableVertexAttribArray(0);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoordBufferData, gl.STATIC_DRAW);
            gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0,);
            gl.enableVertexAttribArray(1);

            //** create TEXTURE -----------------------------------------------------
            const loadTexture = () => new Promise(resolve => {
                const image = new Image();
                image.addEventListener('load',()=> resolve(image));
                image.src = './horse.png';
            }); 
            
            
            const run =  async ()=> {

                const image = await loadTexture();
                
                const textureSlot = 1;
                gl.activeTexture(gl.TEXTURE0 + textureSlot);
                gl.uniform1i(u_sampler,textureSlot);
                
                // gl.uniform2fv(u_uvOffset, new Float32Array([0.0,0.0]));
                gl.uniform2fv(uvScale, new Float32Array([0.33, 0.33]));
                
                
                const texture = gl.createTexture();
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);
                gl.bindTexture(gl.TEXTURE_2D,texture);

                gl.texImage2D(gl.TEXTURE_2D,0 ,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);
                // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 4, 4, 0, gl.RGB, gl.UNSIGNED_BYTE, pixels);
                //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 4, 4, 0, gl.RGB, gl.UNSIGNED_BYTE, 0);
                
                gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
                
                // gl.generateMipmap(gl.TEXTURE_2D);
                // gl.bindTexture(gl.TEXTURE_2D,null);
                
                gl.clearColor(0.2, 0.2, 0.2, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                let time_prev = 0;
                let frameindex = 0;
                let time_frame = 0;
                const animate = function (time) {
                    const dt = time - time_prev;
                    time_prev = time;

                    const dt_time_frame = time - time_frame;
                    console.log(dt_time_frame)
                    if(dt_time_frame >= 100){
                        if(frameindex == 6){
                            frameindex = 0; 
                        }else{
                            frameindex++    
                        }
                    time_frame = time;
                    console.log(time_frame)
                    }
                    
                    // console.log(frameindex)
                    gl.uniform2fv(u_uvOffset, new Float32Array(frameUV[parseInt(frameindex)]));

                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.clearColor(0.2, 0.2, 0.2, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                    gl.flush();

                    window.requestAnimationFrame(animate);
                };
                animate(0);

                };

                run();
            }


    </script>
</head>

<body onload="webGLStart();">

<canvas id="canvasGL" style="border: solid;" width="400" height="400"></canvas>
<br/><br />



</body>
</html>
